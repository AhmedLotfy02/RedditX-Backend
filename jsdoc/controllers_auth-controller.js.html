<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controllers/auth-controller.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controllers/auth-controller.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const User = require("../models/user-model");
const bcrypt = require("bcryptjs");
const decodeJwt = require("./google-facebook-oAuth");
const randomUsername = require("../utils/random-username");
const catchAsync = require("../utils/catch-async");
const UserService = require("./../services/user-service");

const userServiceInstance = new UserService(User);

/**
 * Check whether user name is in database or not (function)
 * @param {Object} username username of the user.
 * @returns {String} state of the operation whether false or true to indicate the sucess.
 * @returns {Object} user return from the database.
 */
const availableUser = async (username) => {
  const user = await User.findById(username);
  if (user) {
    return {
      state: false,
      user: user,
    };
  } else {
    return {
      state: true,
      user: null,
    };
  }
};

/**
 * Check whether email is in database or not (function)
 * @param {String} email  state of the operation whether false or true to indicate the sucess.
 * @returns {Boolean} exist whether the email exists or not.
 */
const availableEmail = async (email) => {
  const user = await User.findOne({ email: email });
  if (user) {
    return {
      exist: true,
    };
  } else {
    return {
      exist: false,
    };
  }
};
/**
 * Check whether google account or facebook account is in database or not (function)
 * @param {String} email the email that will be searched by in the database.
 * @param {String} type the type of the email that will be searched by in the database.
 * @returns {Object} user the returned user from the database.
 * @returns {Boolean} exist whether the email exists or not.
 */
const availabeGmailOrFacebook = async (email, type) => {
  const user = await User.findOne({ email: email, type: type });
  if (user) {
    return {
      exist: true,
      user: user,
    };
  } else {
    return {
      exist: false,
      user: null,
    };
  }
};

// /**
//  * Check whether google account or facebook account is in database or not (route)
//  * @param {Object} req request that contain email and type.
//  * @returns {String} response whether available or not.
//  */
// const availableGorF = async (req, res) => {
//   const data = await availabeGmailOrFacebook(req.body.email, req.body.type);
//   if (data.exist == false) {
//     return res.status(200).json({
//       response: "Avaliable",
//     });
//   } else {
//     return res.status(404).json({
//       response: "Not Avaliable",
//     });
//   }
// };

/**
 * Change password according to type of email
 * @param {param} type type of the email.
 * @param {param} password password of the email.
 * @returns {String} (type whether '1' or the password parameter).
 */
const changePasswordAccType = (type, password) => {
  return type == "facebook" || type == "gmail" ? "1" : password;
};

/**
 * Check whether username is in database or not (route)
 * @param {Object} req request that contains the username.
 * @param {Object} res
 * @returns {object} response whether available or not.
 */
const availableUsername = async (req, res) => {
  const data = await availableUser(req.query.username);
  if (data.state) {
    return res.status(200).json({
      response: "Avaliable",
    });
  } else {
    return res.status(404).json({
      response: "Not Avaliable",
    });
  }
};

/**
 * Save user in database
 * @param {String} email email of the user
 * @param {String} hash hashed password
 * @param {String} username username of the user
 * @param {String} type type of the email
 * @returns {object} (status,username)
 */
const createUser = async (email, hash, username, type) => {
  const user = new User({
    email: email,
    password: hash,
    _id: username,
    type: type,
    isPasswordSet: type == "gmail" || type == "facebook" ? false : true,
  });
  const result = user
    .save()
    .then(() => {
      return {
        username: user._id,
        status: "done",
      };
    })
    .catch((err) => {
      return {
        username: null,
        status: "error",
        error: err,
      };
    });
  return result;
};

/**
 * Signup (route)
 * @param {Object} (req, res)
 * @returns {object} {token,expiresIn,username} or {error}
 */
const signup = async (req, res) => {
  const pass = changePasswordAccType(req.body.type, req.body.password);
  const hash = await bcrypt.hash(pass, 10);
  if (req.body.type == "gmail" || req.body.type == "facebook") {
    const decodeReturn = decodeJwt.decodeJwt(req.body.googleOrFacebookToken);
    if (decodeReturn.error != null) {
      return res.status(400).json({
        error: "invalid token",
      });
    }
    const email = decodeReturn.payload.email;
    const data = await availabeGmailOrFacebook(email, req.body.type);
    //case if not available in database random new username and send it
    if (data.exist == false) {
      const username = randomUsername.randomUserName();
      const result = await createUser(email, hash, username, req.body.type);
      if (result.username != null) {
        const token = userServiceInstance.signToken(req.body.type, username);
        return res.status(200).json({
          token: token, //token,
          expiresIn: 3600 * 24,
          username: username,
        });
      } else {
        return res.status(400).json({
          error: "error happened",
        });
      }
    } else {
      const token = userServiceInstance.signToken(req.body.type, data.user_id);
      return res.status(200).json({
        token: token, //token,
        expiresIn: 3600 * 24,
        username: data.user._id,
      });
    }
  } else {
    //signup with bare email
    const data = await availableEmail(req.body.email);
    if (data.exist)
      return res.status(400).json({
        error: "Duplicate email!",
      });
    const result = await createUser(
      req.body.email,
      hash,
      req.body.username,
      req.body.type
    );
    if (result.username != null) {
      const token = await userServiceInstance.signToken(
        req.body.type,
        req.body.username
      );

      return res.status(200).json({
        token: token, //token,
        expiresIn: 3600 * 24,
        username: req.body.username,
      });
    } else {
      return res.status(400).json({
        error: "duplicate username",
      });
    }
  }
};

/**
 * Login (route)
 * @param {Object} req req must contain the correct data.
 * @param {Object} res
 * @returns {object} {token,expiresIn,username} or {error}
 */

const login = async (req, res) => {
  const pass = changePasswordAccType(req.body.type, req.body.password);
  const hash = await bcrypt.hash(pass, 10);
  if (req.body.type == "gmail" || req.body.type == "facebook") {
    const decodeReturn = decodeJwt.decodeJwt(req.body.googleOrFacebookToken);
    if (decodeReturn.error != null) {
      return res.status(404).json({
        error: "invalid token",
      });
    }
    const email = decodeReturn.payload.email;
    const data = await availabeGmailOrFacebook(email, req.body.type);
    //case if not available in database random new username and send it
    if (data.exist == false) {
      const username = randomUsername.randomUserName();
      const result = await createUser(email, hash, username, req.body.type);
      if (result.username != null) {
        const token = userServiceInstance.signToken(req.body.type, username);
        return res.status(200).json({
          token: token, //token,
          expiresIn: 3600 * 24,
          username: username,
        });
      } else {
        return res.status(404).json({
          error: "error happened",
        });
      }
    } else {
      const token = userServiceInstance.signToken(req.body.type, data.user_id);
      return res.status(200).json({
        token: token, //token,
        expiresIn: 3600 * 24,
        username: data.user._id,
      });
    }
  } else {
    User.findById(req.body.username)
      .then((user) => {
        if (!user) {
          return res.status(404).json({
            type: "bare email",
            error: "Wrong username or password.",
          });
        }
        return bcrypt.compareSync(req.body.password, user.password);
      })
      .then(async (result) => {
        if (!result) {
          return res.status(404).json({
            type: "bare email",
            error: "Wrong username or password.",
          });
        }
        const token = await userServiceInstance.signToken(
          req.body.type,
          req.body.username
        );
        return res.status(200).json({
          token: token,
          expiresIn: 3600 * 24,
          username: req.body.username,
        });
      })
      .catch(() => {
        return res.status(404).json({
          type: "bare email",
          error: "Wrong username or password.",
        });
      });
  }
};

const forgotPassword = catchAsync(async (req, res, next) => {
  if (req.body.operation) {
    // in case of forgot username
    try {
      await userServiceInstance.forgotUsername(req.body.email);
    } catch (err) {
      return next(err);
    }
    return res.status(200).json({
      status: "success",
      message: "Username is sent to the email!",
    });
  }
  try {
    await userServiceInstance.forgotPassword(req.body.username);
  } catch (err) {
    return next(err);
  }
  res.status(200).json({
    status: "success",
    message: "Link is sent to the email!",
  });
});

const resetForgottenPassword = catchAsync(async (req, res, next) => {
  var data = undefined;
  try {
    data = await userServiceInstance.resetForgottenPassword(
      req.params.token,
      req.body.newPassword,
      req.body.confirmedNewPassword
    );
  } catch (err) {
    return next(err);
  }
  return res.status(200).json({
    token: data.token,
    expiresIn: 3600 * 24,
    username: data.id,
  });
});

module.exports = {
  availableEmail,
  availableUser,
  availableUsername,
  signup,
  login,
  forgotPassword,
  resetForgottenPassword,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="APIFeatures.html">APIFeatures</a></li><li><a href="AppError.html">AppError</a></li><li><a href="CommentService.html">CommentService</a></li><li><a href="CommunityService.html">CommunityService</a></li><li><a href="NotificationService.html">NotificationService</a></li><li><a href="PostService.html">PostService</a></li><li><a href="global.html#Service">Service</a></li><li><a href="UserService.html">UserService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#APIfeatures">APIfeatures</a></li><li><a href="global.html#availabeGmailOrFacebook">availabeGmailOrFacebook</a></li><li><a href="global.html#availableEmail">availableEmail</a></li><li><a href="global.html#availableUser">availableUser</a></li><li><a href="global.html#availableUsername">availableUsername</a></li><li><a href="global.html#banOrMute">banOrMute</a></li><li><a href="global.html#block">block</a></li><li><a href="global.html#changePasswordAccType">changePasswordAccType</a></li><li><a href="global.html#createUser">createUser</a></li><li><a href="global.html#getBanned">getBanned</a></li><li><a href="global.html#getCommunityOptions">getCommunityOptions</a></li><li><a href="global.html#getModerates">getModerates</a></li><li><a href="global.html#getModerators">getModerators</a></li><li><a href="global.html#getMuted">getMuted</a></li><li><a href="global.html#getNotifications">getNotifications</a></li><li><a href="global.html#getPosts">getPosts</a></li><li><a href="global.html#getSubscribed">getSubscribed</a></li><li><a href="global.html#getUserAbout">getUserAbout</a></li><li><a href="global.html#getUserComments">getUserComments</a></li><li><a href="global.html#getUserDownVoted">getUserDownVoted</a></li><li><a href="global.html#getUserMe">getUserMe</a></li><li><a href="global.html#getUserOverview">getUserOverview</a></li><li><a href="global.html#getUserPrefs">getUserPrefs</a></li><li><a href="global.html#getUserSubmitted">getUserSubmitted</a></li><li><a href="global.html#getUserUpVoted">getUserUpVoted</a></li><li><a href="global.html#globalErrorHandler">globalErrorHandler</a></li><li><a href="global.html#handleCastErrorDB">handleCastErrorDB</a></li><li><a href="global.html#handleDuplicateFieldDB">handleDuplicateFieldDB</a></li><li><a href="global.html#handleValidatorErrorDB">handleValidatorErrorDB</a></li><li><a href="global.html#login">login</a></li><li><a href="global.html#mergeTwo">mergeTwo</a></li><li><a href="global.html#multerFilter">multerFilter</a></li><li><a href="global.html#multerStorage">multerStorage</a></li><li><a href="global.html#resizeCommunityBanner">resizeCommunityBanner</a></li><li><a href="global.html#resizeCommunityIcon">resizeCommunityIcon</a></li><li><a href="global.html#resizeUserPhoto">resizeUserPhoto</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#sendErrorDev">sendErrorDev</a></li><li><a href="global.html#sendErrorProd">sendErrorProd</a></li><li><a href="global.html#setSuggestedSort">setSuggestedSort</a></li><li><a href="global.html#signup">signup</a></li><li><a href="global.html#spam">spam</a></li><li><a href="global.html#submit">submit</a></li><li><a href="global.html#unsave">unsave</a></li><li><a href="global.html#uploadCommunityBanner">uploadCommunityBanner</a></li><li><a href="global.html#uploadCommunityIcon">uploadCommunityIcon</a></li><li><a href="global.html#uploadUserPhoto">uploadUserPhoto</a></li><li><a href="global.html#userAbout">userAbout</a></li><li><a href="global.html#userComments">userComments</a></li><li><a href="global.html#userDownVoted">userDownVoted</a></li><li><a href="global.html#userMe">userMe</a></li><li><a href="global.html#userOverview">userOverview</a></li><li><a href="global.html#userPrefs">userPrefs</a></li><li><a href="global.html#userSubmitted">userSubmitted</a></li><li><a href="global.html#userUpVoted">userUpVoted</a></li><li><a href="global.html#vote">vote</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Wed Nov 23 2022 01:55:47 GMT+0200 (Eastern European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
